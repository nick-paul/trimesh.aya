.# 3D Projected Cube
.#
.# Implementation of Coding Challenge #112 by The Coding Train
.# https://thecodingtrain.com/


import ::canvas
import ::color
import ::time
import ::la
from ::trimesh import ::trimesh

.# suzanne, teapot, bunny
"bunny":model;

{
    ("suzanne" model =) {
        .# Suzanne
        "suzanne.obj" trimesh.read_obj :mesh;
        100 mesh.rescale :mesh;
        0   :point_size;
        0.8 :point_alpha;
        1   :draw_wireframe;
    } ("teapot" model =) {
        "teapot.obj" trimesh.read_obj :mesh;
        50 mesh.rescale :mesh;
        1   :point_size;
        0.8 :point_alpha;
        0   :draw_wireframe;
    } ("bunny" model = ) {
        "stanford-bunny.obj" trimesh.read_obj :mesh;
        1500 mesh.rescale :mesh;
        1   :point_size;
        0.3 :point_alpha;
        0   :draw_wireframe;
    } {
        "Please use a valid model name" .D
    }
} :?

.# Flip it upright
:1p mesh.rotate_z :mesh;

.# Center the mesh on the origin
mesh.points mesh.get_center.T - mesh.:points;

.# Create a new canvas
{, "trimesh example: $model":name 0:autoflush 1:scale } canvas! :c;

.# Tf mat
.# Draw the origin in the middle of the screen rather than the corner
[c.width 2/ c.height 2/] .T  :canvas_tf;


.# Rotation
0 :theta;

.# Render at 50 FPS
30 time.rate! :limiter;

.# Draw loop
{
    .#
    .# UPDATE
    .#

    theta 0.02 + :theta;

    mesh :mesh_rotated;
    theta mesh_rotated.rotate_x :mesh_rotated;
    theta mesh_rotated.rotate_y :mesh_rotated;
    theta mesh_rotated.rotate_z :mesh_rotated;

    .# Project the points and apply canvas transform
    .# (Move the points to the center of the canvas)
    mesh_rotated.project canvas_tf + :canvas_points;

    .#
    .# DRAW
    .#

    .# Black Background
    color.colors.black c.set_color
    1     c.set_alpha
    c.clear
    0 0 c.width c.height c.fillrect

    .# Draw Points
    color.colors.white c.set_color
    point_alpha c.set_alpha

    point_size 0 > {
        canvas_points .T point_size c.points
    } ?

    draw_wireframe {

        .#mesh_rotated.faces { {i, canvas_points {iI} O } O } O
        canvas_points mesh_rotated.faces trimesh.face_points :# {triangle,
            triangle .T ~ 0 c.path
        } ;
    } ?

    c.show
    limiter.sleep
    c.isopen
} W

c.close
